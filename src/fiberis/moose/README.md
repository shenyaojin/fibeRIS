# `fiberis.moose`

This package provides a powerful Python interface to the MOOSE (Multiphysics Object-Oriented Simulation Environment) framework. It is designed to automate the entire simulation workflow, from creating complex input files programmatically to running the simulation and post-processing the results.

## Core Goal

The primary goal of this package is to bring the full power of MOOSE into a Python-driven environment, enabling users to:

-   **Automate Input File Creation**: Dynamically generate MOOSE input files (`.i` files) from Python objects, which is ideal for parameter studies, optimization, and complex model setups.
-   **Control Simulation Execution**: Programmatically run MOOSE simulations, including parallel execution with MPI.
-   **Edit Existing Inputs**: Load, modify, and save existing MOOSE input files.
-   **Post-process Results**: Extract and analyze data from MOOSE output files (Exodus `.e` and CSV).

## Modules

### 1. `config.py`: Configuration Objects

-   **Purpose**: Defines a set of intuitive Python classes to represent physical and numerical concepts in a MOOSE simulation.
-   **Key Classes**:
    -   `ZoneMaterialProperties`: A container for material properties like porosity and permeability.
    -   `MatrixConfig`, `SRVConfig`, `HydraulicFractureConfig`: High-level classes to define the properties and geometry of different reservoir zones.
    -   `AdaptivityConfig`, `IndicatorConfig`, `MarkerConfig`: Classes for setting up adaptive mesh refinement (AMR).
    -   `PostprocessorConfig`, `PointValueSamplerConfig`, `LineValueSamplerConfig`: Configurations for various data-sampling post-processors.
    -   `SimpleFluidPropertiesConfig`: Defines fluid properties.
    -   `AdaptiveTimeStepperConfig`: Configures advanced, iteration-adaptive time-stepping.

### 2. `model_builder.py`: The `ModelBuilder`

-   **Purpose**: This is the high-level, primary interface for building a MOOSE input file. It uses the configuration objects from `config.py` to construct a complete simulation setup.
-   **Key Features**:
    -   **Stitched Mesh Generation**: Includes a robust, data-driven system (`build_stitched_mesh_for_fractures`) for creating complex 2D meshes with multiple fractures and layers, which is a significant challenge in reservoir simulation.
    -   **Fluent API**: Methods are chainable (e.g., `builder.add_variables(...).add_kernels(...)`), allowing for clean and readable script construction.
    -   **Comprehensive Coverage**: Provides methods to add and configure nearly every major MOOSE block, including `[Variables]`, `[Kernels]`, `[BCs]`, `[Materials]`, `[Executioner]`, `[Postprocessors]`, and more.
    -   **Intelligent Defaults**: Sets up complex blocks like `[Materials]` and `[Preconditioning]` with sensible defaults for poromechanics problems.

### 3. `input_generator.py`: Low-Level Input Generation

-   **Purpose**: Provides the low-level machinery for converting Python objects into the text format of a MOOSE input file. It is used internally by the `ModelBuilder`.
-   **Key Class**: `MooseBlock`, which represents a generic `[...]` block in the input file and can render itself and its parameters/sub-blocks to the correct string format.

### 4. `input_editor.py`: The `MooseInputEditor`

-   **Purpose**: Allows for the modification of *existing* MOOSE input files.
-   **Key Features**: Uses the `pyhit` and `moosetree` libraries (part of the MOOSE environment) to parse a `.i` file into a navigable tree structure. You can then programmatically find nodes (blocks), get/set parameter values, and write the modified tree back to a new file. This is useful for making small changes to existing complex input files.

### 5. `runner.py`: The `MooseRunner`

-   **Purpose**: Executes a MOOSE simulation from Python.
-   **Key Features**:
    -   Constructs the correct command-line call, including handling parallel execution with `mpiexec`.
    -   Manages the working directory, staging input files as needed.
    -   Captures and returns the `stdout` and `stderr` streams from the simulation, allowing for programmatic success/failure checks and output parsing.

### 6. `postprocessor.py`: Results Analysis

-   **Purpose**: Provides tools for reading and extracting data from MOOSE output files.
-   **Key Classes**:
    -   `MooseOutputReader`: (Currently facing issues with `meshio`) Designed to read Exodus (`.e`) files to extract mesh information and field data (e.g., pressure or displacement over the entire domain at different time steps).
    -   `MoosePointSamplerSet`: A robust reader for the CSV files generated by `PointSampler` post-processors. It automatically discovers all point samplers in an output directory, loads them, and provides plotting utilities.

## Typical Workflow

1.  Define the simulation using the configuration classes in `config.py`.
2.  Instantiate `ModelBuilder` and use its methods to build the complete simulation by adding the configuration objects.
3.  Call `builder.generate_input_file()` to write the `.i` file.
4.  Instantiate `MooseRunner` with the path to your compiled MOOSE application.
5.  Call `runner.run()` with the generated `.i` file to execute the simulation.
6.  Use `MoosePointSamplerSet` to load and analyze time-history data from the output directory.
