# fibeRIS MOOSE extension

This package provides tools to interface with the MOOSE (Multiphysics Object-Oriented Simulation Environment) framework, enabling the programmatic generation of input files, execution of simulations, and (eventually) post-processing of results within the `fibeRIS` project.

## Overview

The primary goal of this package is to automate and streamline MOOSE-based simulation workflows. This includes:
1.  **Input File Generation**: Dynamically creating MOOSE input files (`.i` files) based on Python-defined configurations. This allows for easy parameterization, sensitivity analysis, and integration with other Python-driven calculations.
2.  **Simulation Execution**: Programmatically running MOOSE simulations using the generated input files, capturing output, and managing the execution process.
3.  **Results Post-processing (Future)**: Providing utilities to read, analyze, and visualize data from MOOSE output files (e.g., Exodus `.e` files, CSVs).

## Modules

### 1. `input_generator.py`

* **Purpose**: Generates MOOSE input files (`.i` files) from Python dictionary configurations.
* **Key Class**:
    * `MooseBlock`: A generic class representing a block (e.g., `[Mesh]`, `[Variables/u]`) in a MOOSE input file. It handles parameters and nested sub-blocks.
    * `FunctionBlock` (and potentially other specific block classes): Specialized classes inheriting from `MooseBlock` for common MOOSE block types with specific formatting needs (e.g., `ParsedFunction` expressions).
* **Key Function**:
    * `generate_moose_input(config: Dict, output_filepath: str)`: Takes a configuration dictionary and an output file path, and writes a complete MOOSE input file.
* **Usage**:
    * Define a Python dictionary where keys are top-level MOOSE block names (e.g., "Mesh", "Variables", "Kernels").
    * The values for these keys are either:
        * A dictionary of parameters if the top-level block has direct parameters (e.g., `{"Mesh": {"file": "mesh.e"}}`).
        * A list of dictionaries if the top-level block contains sub-blocks (e.g., `{"Variables": [{"name": "./u", "params": {"order": "FIRST"}}]}`). Each dictionary in the list defines a sub-block with its `name`, `type` (if applicable), and `params`.
    * This configuration is then passed to `generate_moose_input` to produce the `.i` file.

### 2. `runner.py`

* **Purpose**: Executes MOOSE simulations using a specified input file.
* **Key Class**:
    * `MooseRunner(moose_executable_path: str)`: Manages the execution of MOOSE simulations. Requires the path to the compiled MOOSE application executable.
* **Key Function**:
    * `run(input_file_path: str, output_directory: Optional[str], num_processors: int, ...)`: Constructs and runs the MOOSE command (handling MPI via `mpiexec` if `num_processors > 1`). It captures stdout, stderr, and the return code.
* **Usage**:
    * Instantiate `MooseRunner` with the path to your MOOSE application.
    * Call the `run()` method, providing the path to the `.i` file (generated by `input_generator.py` or otherwise) and other execution parameters like the number of processors and an optional output directory.
    * The method returns a tuple indicating success/failure and the captured output streams.

### 3. `postprocessor.py` (Planned)

* **Purpose**: Will provide tools for reading and processing output files generated by MOOSE simulations (e.g., Exodus `.e` files, CSV files).
* **Potential Functionality**:
    * Extracting specific field variables.
    * Reading time-history data from postprocessors.
    * Converting data into formats suitable for `fibeRIS` analysis tools (e.g., NumPy arrays, Pandas DataFrames).
    * Basic plotting or interfacing with visualization libraries.

## Typical Workflow

A typical workflow using this package would involve:

1.  Defining a Python configuration dictionary that specifies all parameters for a MOOSE simulation.
2.  Using `input_generator.generate_moose_input()` to create the `.i` file from this configuration.
3.  Instantiating `runner.MooseRunner` with the path to the relevant MOOSE executable.
4.  Calling `runner.run()` with the generated `.i` file to execute the simulation.
5.  (Once implemented) Using `postprocessor` utilities to load and analyze the simulation results.

This workflow is particularly well-suited for:
* Automated parameter sweeps and sensitivity studies.
* Integrating MOOSE simulations into larger Python-based scientific computing pipelines.
* Reproducible research by programmatically defining and executing simulations.

## Future Considerations

* Integration with `pyhit` for modifying existing MOOSE input files as an alternative to full generation.
* More sophisticated error handling and logging in the `runner`.
* Support for different MPI launchers in the `runner`.
* Development of the `postprocessor.py` module.